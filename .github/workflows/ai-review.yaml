name: AI PR & Issue Assistant with Auto-Label

on:
  pull_request:
    types: [opened, synchronize]
  issues:
    types: [opened]

jobs:
  ai-assistant:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Prepare Context
        id: prep
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            git fetch origin ${{ github.base_ref }}
            git diff origin/${{ github.base_ref }}...HEAD > input_content.txt
            echo "type=PR" >> $GITHUB_OUTPUT
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            echo -e "Title: ${{ github.event.issue.title }}\n\n${{ github.event.issue.body }}" > input_content.txt
            echo "type=Issue" >> $GITHUB_OUTPUT
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - name: AI Processing & Labeling
        uses: actions/github-script@v7
        env:
          API_KEY: ${{ secrets.OPENAI_API_KEY }}
          BASE_URL: ${{ secrets.OPENAI_BASE_URL }}
          MODEL: ${{ secrets.AI_MODEL }}
          EVENT_TYPE: ${{ steps.prep.outputs.type }}
          ISSUE_NUMBER: ${{ steps.prep.outputs.number }}
          ENABLE_AUTO_LABEL: "true" # è®¾ç½®ä¸º "false" åˆ™å½»åº•å…³é—­è‡ªåŠ¨æ‰“æ ‡ç­¾åŠŸèƒ½
        with:
          script: |
            const fs = require('fs');
            const content = fs.readFileSync('input_content.txt', 'utf8');
            if (!content.trim()) return;

            // 1. èŽ·å–ä»“åº“çŽ°æœ‰çš„æ‰€æœ‰ Labels
            const { data: repoLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const labelNames = repoLabels.map(l => l.name);

            // 2. æž„å»ºé’ˆå¯¹æ ‡ç­¾çš„ Prompt 
            let labelInstruction = "";
            if (process.env.ENABLE_AUTO_LABEL === "true") {
              labelInstruction = `
            è¯·ä»Žä»¥ä¸‹çŽ°æœ‰çš„æ ‡ç­¾åˆ—è¡¨ä¸­é€‰æ‹©æœ€åˆé€‚çš„æ ‡ç­¾ï¼ˆå¯å¤šé€‰ï¼‰ï¼Œä»…ä»Žåˆ—è¡¨ä¸­é€‰æ‹©ï¼š[${labelNames.join(", ")}]ã€‚
            å¦‚æžœä½ è®¤ä¸ºä¸éœ€è¦æ‰“æ ‡ç­¾ï¼Œè¯·è¿”å›žç©ºæ•°ç»„ã€‚
            è¯·åœ¨å›žå¤çš„æœ€å¼€å¤´ä»¥ JSON æ ¼å¼è¾“å‡ºä½ çš„é€‰æ‹©ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
            {"suggested_labels": ["label1", "label2"]}
            ç„¶åŽå¦èµ·ä¸€è¡Œå¼€å§‹ä½ çš„è¯„è®ºåˆ†æžã€‚`;
            }

            const prompt = process.env.EVENT_TYPE === 'PR' 
              ? `ä½ æ˜¯ä¸€ä½èµ„æ·±å·¥ç¨‹å¸ˆã€‚è¯·å®¡æŸ¥ä»¥ä¸‹ PR çš„ä»£ç æ”¹åŠ¨ï¼ŒæŒ‡å‡ºæ½œåœ¨ Bug å’Œæ”¹è¿›ç‚¹ã€‚${labelInstruction}\n\nDiffå†…å®¹ï¼š\n${content}`
              : `ä½ æ˜¯ä¸€ä½å¼€æºé¡¹ç›®ç»´æŠ¤è€…ã€‚è¯·åˆ†æžä»¥ä¸‹ Issue å¹¶ç»™å‡ºå»ºè®®ã€‚${labelInstruction}\n\nIssueå†…å®¹ï¼š\n${content}`;

            try {
              const response = await fetch(`${process.env.BASE_URL}/chat/completions`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.API_KEY}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: process.env.MODEL,
                  messages: [{ role: "user", content: prompt }],
                  temperature: 0.2
                })
              });

              const data = await response.json();
              const fullText = data.choices[0].message.content;

              // 3. è§£æžæ ‡ç­¾å’Œæ­£æ–‡
              let commentBody = fullText;
              let labelsToAdd = [];

              if (process.env.ENABLE_AUTO_LABEL === "true") {
                const jsonMatch = fullText.match(/^\{.*?\}/); // åŒ¹é…å¼€å¤´çš„ JSON
                if (jsonMatch) {
                  try {
                    const labelData = JSON.parse(jsonMatch[0]);
                    labelsToAdd = labelData.suggested_labels || [];
                    commentBody = fullText.replace(jsonMatch[0], "").trim();
                  } catch (e) {
                    console.log("Failed to parse labels JSON");
                  }
                }
              }

              // 4. å‘å¸ƒè¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(process.env.ISSUE_NUMBER),
                body: `### ðŸ¤– AI ${process.env.EVENT_TYPE === 'PR' ? 'Review' : 'Assistant'}\n\n${commentBody}`
              });

              // 5. è‡ªåŠ¨æ‰“æ ‡ç­¾ï¼ˆå¦‚æžœæœ‰å»ºè®®çš„æ ‡ç­¾ï¼‰
              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(process.env.ISSUE_NUMBER),
                  labels: labelsToAdd
                });
              }
            } catch (err) {
              core.setFailed(err.message);
            }
